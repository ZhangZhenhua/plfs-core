~~~ Version 1.0pre.0 

1) Problems with building the PLFS SC09 paper.  Problems are in data/summary
directory.  When make does ./get_data > data, it was failing due to a bad
reference count because we were incrementing the writers when a child came
in and used the parent's fd.  Then when the file was closed, it asserted since
the reference count was still 1.  So now we don't increment the writers for
children but now we're still seeing this other strange behavior:
jvpn-132-65:/tmp/plfs_mnt/SC09/data/summary>./get_data >! data
cat: stdout: Result too large

2) plfs_read is now multi-threaded when a logical read spans multiple physical
data chunks.  In addition, if these chunks need to be opened that is done in
the threads as well so we parallelize both the opens and the reads

3) Container::populateIndex is now multi-threaded when the container has
more than one index file.  This means of course that overlapped writes are
now non-deterministically handled in addition to being undefined as they
were previously.

4) Moved the mapping from a logical file to a physical path into the plfs
library and out of fuse.  The mapping consults a plfsrc file in order to
know how to distribute users across multiple backends.

~~~ Version 0.1.6

1) Gary found a bug in the old version running on cuda.lanl.gov.  I tried to 
reproduce it but found it was no longer in 0.1.5.  The test was just doing
a bunch of dd's with increasing offsets and then reading from another node.
Just sure what was causing that bug.  Didn't go back and debug old versions.
But while investigating that bug, I found another bug that was caused when
dd would truncate a file and the index file trunctated would be truncated 
at the first entry and then would be empty.  But I was assuming that it 
wasn't empty so I was checking the entry before the truncate point to see
if it needed to be partially truncated.  But when there was no entry, then
this was tromping memory.

~~~ Version 0.1.5

1) Fixed a bug where temp dirs used to attempt to create the container were
not being deleted when some other node created the container first.  The 
problem was that we changed from SUID to accessfile to identify a container
and we weren't removing the accessfile in the temporary container before
trying to unlink the temporary container.

2) Added a container/version/$(TAG_VERSION) dropping so in the future we can
make sure to be backward compatible.

~~~ Version 0.1.5

1) Changed the behavior of truncate to not remove droppings but just to truncate
them.  This was needed because we discovered that if one proc already has open
handles to droppings, another can do a truncate, and then those droppings 
disappear when the handles are closed.  This was discovered using the qio
tests which don't do barriers after open and closes.

2) Fixed reference counting bugs in the Plfs_fd structure.  Again this was 
discovered due to the lack of barriers in the qio tests.  When we had 
simultaneous readers and writers in a Plfs_fd structure, some of the closes
were screwing up the reference counting, and other thread's Plfs_fd structures
were being removed out from under them.

3) cvs co was causing problems because it was renaming open files.  I thought
I had fixed that before but it cropped up again.  Now in the rename, when we
are renaming an open file, we remove the old open file, we change it's 
internal names, and we add it back again as a new open file.  There's a bunch
of comments in plfs_fuse.cpp:f_rename about this as well.

4) Fixed a bug that was caused by layering PLFS's (e.g. running PLFS-MPI onto
a PLFS-MNT) which was causing this problem:
	a) the app creates file 'foo'
	b) PLFS-MPI does mkdir 'foo' on PLFS-MNT
	c) PLFS-MNT does mkdir 'foo' on PLFS-BACK
	d) PLFS-MPI touches 'foo/access' on PLFS-MNT
	e) PLFS-MNT does mkdir 'foo/access' on PLFS-BACK
	f) PLFS-MPI tries to access directory 'foo'
	g) PLFS-MNT thinks 'foo' is a container since it has an access entry
	h) PLFS-MPI gets confused bec what was a directory is now a file
Also, this revealed a bug where PLFS library thought that mmap returned NULL
on error, but really it returns MAP_FAIL, so PLFS library didn't notice when
mmap failed and this caused a segfault.  To fix this, the check for the access
file checks both existence and whether it is a file.  Now when the PLFS-MPI
does a touch of 'foo/access,' the PLFS-MNT makes a 'foo/access' directory, so 
when PLFS-MPI looks at 'foo,' PLFS-MNT doesn't find a 'foo/access' file, so it
treats 'foo' as a directory which is the proper behavior in this confusing
layered case.  This also revealed the worse problem that a user can never
create an 'access' entry in a directory because PLFS will start treating that
directory as a container and when it doesn't have the other entries that PLFS
expects in a container, it gets all weird.  So to fix this, we have broken
backwards compatibility by changing the name of the access file from 'access'
to '.plfsaccess081173'  At some point, we need to add backward compatibility
checking.

5) Fixed it so that the plfs_map in the trace/ directory is correctly built
again.  I tried to change it so that it builds from the library only but it
access the low-level index calls so that doesn't work.  So now it builds by
just using all the src/*.o files instead of just trying to link with the
library alone.
